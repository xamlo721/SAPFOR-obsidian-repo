Граф массивов является основной структурой данных, на основе которой строятся распределение данных и вычислений. Построение графа массивов обусловлено выбором целевой модели при создании параллельной версии программы. DVMH-модель требует выполнения правила собственных вычислений: каждый процессор изменяет только собственные данные, то есть данные, которые распределены на этот процессор. Кроме того вычисление одной итерации цикла должно целиком выполняться на одном процессоре, и следовательно элементы массивов, вычисляемые на одной итерации оказываются связаны между собой и должны быть размещены на одном процессоре.

Для соблюдения данного правила необходимо использовать взаимное выравнивание массивов между собой с помощью спецификации **ALIGN**. После распределения массивов с помощью спецификаций **DISTRIBUTE** и **ALIGN** получается дерево выравнивания, которое описывает связи между всеми массивами. Правило собственных вычислений требует, чтобы все массивы, используемые в одном цикле, принадлежали одному дереву выравнивания.

Граф массивов представлен в системе SAPFOR в формате CSR (**Compressed Sparse Rows**) и является неориентированным. Каждое измерение массива становится узлом графа, а дуги показывают связь одного измерения массива с другим. Для заполнения графа массивов необходимо обработать информацию о вычисленных коэффициентах a, b в обращениях к массивам и их связях с циклом. Каждая дуга в графе массивов связывает одно измерение массива Arr1 с измерением массива Arr2. Дуги добавляются по следующему принципу (W или Write означает обращение на запись, R или Read означает обращение на чтение):

	• связываются измерения массивов, обращения по которым присутствуют в левой части операторов присваивания в цикле с типом дуги запись-запись (связь W - W) и весом Loop_w \* SumB;
	
	• связываются измерения массивов Arr1 и Arr2, причем обращение к массиву Arr1 содержится в левой части операторов присваивания, а обращение к массиву Arr2 содержится в правой части операторов присваивания или в условиях IF, причем не обязательно, чтобы массивы Arr1 и Arr2 были в одном операторе. Связь создается с типом дуги запись-чтение (связь W - R) по данному циклу с весом Loop_w \* SumB;

	• в случае отсутствия операций записи в массивы связываются измерения массивов, обращения по которым присутствуют в правой части операторов присваивания или условиях IF в данном цикле, причем два обращения к разным массивам не обязаны быть в одном операторе. Связь создается с типом дуги чтение-чтение (связь R - R) по данному циклу с весом Loop_w \* SumB.

Под SumB понимается совокупное количество байт, которое потребуется передать другим процессорам в случае неудовлетворения конкретной связи с циклом. В худшем случае необходимо передать целиком все измерение массива, отображенное на соответствующий цикл. Количество байт вычисляется из размерности типа используемого массива и номера измерения массива. **Данные о размерах массивов всегда известны системе SAPFOR** и должны быть получены либо от статического, либо от динамического анализов, либо от пользователя, иначе невозможно построить дерево выравнивания в модели DVMH.

Под Loop_w понимается вес цикла. В зависимости от количества арифметических опе
раций и обращений к массивам в телах циклов тот или иной цикл с меньшим  количеством витков может выполняться дольше аналогичного цикла, но с большим количеством витков.

**Вес цикла** оценивается статическим образом, либо путем динамического профилирования (получение времени выполнения данного цикла). Вес цикла показывает сколько раз цикл был выполнен за все время работы программы. Например, если цикл выполняется всего один раз (цикл инициализации), то можно пожертвовать количеством коммуникаций в данном цикле в пользу итерационного цикла, который может выполняться сотни, а то и тысячи раз, где каждый лишний переданный байт будет серьезно сказываться на производительности программы в целом. В случае недостаточности информации для оценки веса цикла система SAPFOR полагает Loop_w = 1.0, что означает равенство всех циклов в программе.

В случае добавления дуги с одинаковыми вершинами происходит увеличение веса данной дуги путем суммирования текущего веса и веса добавляемой дуги. Данное правило позволит выделить наиболее важные связи, что позволит уменьшить количество пересылок между процессами при выборе определенной схемы распределения данных.

Для того чтобы отличать дуги по типу связи (W - W, W - R, R - R), необходимо расставить приоритеты. Тип дуги с типом связи W - W имеет самый высший приоритет, однако все дуги с типом W - W имеют равный приоритет между собой. Это объясняется тем, что неудовлетворение данной связи приведет к невозможности распараллеливания данного цикла, так как не будет выполнено правило собственных вычислений для связываемых массивов, что в итоге повлечет за собой бОльшие коммуникации (так как все обращения к распределенным массивам на чтение в таком цикле в худшем случае должны быть «покрыты» с помощью доступа к удаленным данным). Дуги с типом связи W - R имеют приоритет над дугами с типом связи R - R. Дуги каждого из типов W - R и R - R имеют также равный приоритет между собой.

Чтобы обеспечить соотношение приоритетов для разных типов дуг, был реализован следующий алгоритм выделения дуг по приоритетам. Сначала посчитаем общую сумму всех дуг с типом R - R, S1 = \sum [R - R]. Затем прибавим число S1 к дугам с типом W - R. Тем самым мы «выделим» приоритет W - R типа над дугами типа R - R, сохранив между тем равный приоритет между схожим типом. Затем вычислим общую сумму весов всех дуг с типами связи W - R и R - R, S2 = S1+\sum [W - R] и добавим теперь число S2 ко всем дугам с типом W - W. Таким образом, будет выполнено правило приоритета дуг: вес любой дуги с типом W - W будет больше, чем W - R и R - R, вес любой дуги с типом W - R будет больше, чем R - R.
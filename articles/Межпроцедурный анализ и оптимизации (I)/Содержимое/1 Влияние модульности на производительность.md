Чтобы понять, в чем могут заключаться проблемы порождаемые модульностью, нужно посмотреть, какие существуют варианты работы компилятора, как компилятор пытается решать те или иные проблемы, какие есть ограничения на используемые компилятором методы анализа. Компилятор должен работать консервативно, т.е. с полным недоверием к программисту и программе и делать ту или иную оптимизацию только если полностью доказана ее корректность.

Самый простой вариант работы компилятора – это однопроходная компиляция. При таком варианте работы компилятор обрабатывает поочередно все функции из исходного файла плюс «держит в голове» все предшествующие декларации. Т.е. компилятор последовательно разбирает символы из исходного файла, заполняет таблицы с различными определениями функций, заводит описания определяемых типов и последовательно разбирает тела всех функций в обрабатываемом исходном файле. Сначала компилятор решает задачу проверки программы на соответствие требованиям стандарта языка, затем он может выполнять различные оптимизации:
- [[Цикловая оптимизация]]
- [[Скалярная оптимизация]]
- [[Оптимизация графа потока управления]]
и т.д. 

По окончании обработки результат сохраняется в объектный файл. При такой работе успешно (и как правило относительно быстро) решается задача – получить работающее приложение, но до оптимальной его работы очень далеко. Причиной этого является то, что компилятор имеет недостаточно информации о нелокальных для обрабатываемой функции объектах. Также компилятор имеет очень мало информации о вызываемых функциях. 

Влияет ли такое положение вещей на производительность приложения и какие существуют проблемы, связанные с использованием вызовов функций?

Проблемы:
[[alias analysis]]
[[Неполнота информации при передаче аргументов]]
[[Вызов функции с неизвестными свойствами]]
[[Циклы с вызовом неизвестных функций]]
[[Затратность вызова функции]]
[[Избыточность при статической линковке]]







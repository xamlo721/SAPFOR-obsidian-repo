Не всегда мы имеем представление для конкретного процесса о том какой длины придут данные, для определения существует как раз выше упомянутая структура **MPI_Status** и некоторые процедуры помогающие эту информацию оттуда извлечь.

Первая процедура которую мы обсудим следующая:

```cpp
int MPI_Get_count(MPI_Status* status, MPI_Datatype datatype, int* count);
```

По структуре **status** процедура определяет сколько данных типа **datatype** передано соответствующим сообщением и записывает результат по адресу **count**.

То есть буквально, если мы получаем сообщение от какого-либо процесса и не знаем сколько точно там передано данных, то можем вызвать процедуру **MPI_Get_count** и узнать какое количество ячеек памяти мы можем считать заполненными корректными данными(если конечно их отправляющий процесс корректно формирует).

Также есть еще одна процедура **MPI_Get_elements**. По синтаксису они отличаются лишь названиями, но назначение слегка разное. Если в сообщении передаются данные не базового типа, а типа который является производным от базовых(то есть составлен с помощью базовых типов), то нам вернет не количество этих данных, а именно количество данных базового типа. Однако в случае если передаются данные базового типа, то функции вернут одинаковые значения.

Также иногда случается так, что нам надо просто пропустить отправку сообщения, но саму процедуру из кода исключать не хочется, либо делать лишние условия в коде не рационально. В таких случаях процесс может отправить сообщение не существующему процессу, номер такого процесса определен константой **MPI_PROC_NULL**. В случае если мы передаем сообщение такому процессу, то процедура сразу завершается с кодом возврата _SUCCESS_.

Хорошо, мы можем принимать на вход какие либо данные и не знать сколько их точно поступает. В таком случае нужно рационально выделять какой-то объем памяти для их сохранения(буферизации). Возникает логичный вопрос о том какой объем выделять, в этом нам поможет процедура **MPI_Probe**. Она позволяет получить информацию о сообщении которое ожидает в очереди на прием не получая самого сообщения. Синтаксис ее выглядит следующим образом:

```cpp
int MPI_Probe(int source, int tag, MPI_Comm comm, MPI_Status* status);
```

Тут мы также определяем от какого процесса получаемое сообщение, с каким тэгом, какой коммуникатор связывает эти процессы и передаем структуру которая запишет необходимую информацию.

Теперь на очень простом примере соединим эти процедуры вместе:

```cpp
#include <iostream>
#include "mpi.h"

using namespace std;

void show_arr(int* arr, int size)
{
	for(int i=0; i < size; i++) cout << arr[i] << " ";
	cout << endl;
}

int main(int argc, char **argv)
{
	int size, rank;
	MPI_Init(&argc, &argv);
	MPI_Comm_size(MPI_COMM_WORLD, &size);
	MPI_Comm_rank(MPI_COMM_WORLD, &rank);

	if(rank == 0)
	{
		int* arr = new int[size];
		
		for(int i=0; i < size; i++) 
			arr[i] = i;
			
		for(int i=1; i < size; i++) 
			MPI_Send(arr, i, MPI_INT, i, 5, MPI_COMM_WORLD);
			
	} else {
	
		int count;
		MPI_Status status;

		MPI_Probe(MPI_ANY_SOURCE, MPI_ANY_TAG, MPI_COMM_WORLD, &status);
		MPI_Get_count(&status, MPI_INT, &count);
		int* buf = new int[count];

		MPI_Recv(buf, count, MPI_INT, MPI_ANY_SOURCE, MPI_ANY_TAG, MPI_COMM_WORLD, &status);
		
		cout << "Process:" << rank << " || Count: " << count << " || Array: ";
		show_arr(buf, count);
	}
	MPI_Finalize();
	return 0;
}
```

Что тут происходит?  
В данной программе первый процесс создает массив размером равным количеству процессов и заполняет его номерами процессов по очереди. Потом соответствующему процессу он отправляет такое число элементов этого массива, какой номер у этого процесса. Например: процесс 1 получит 1 элемент, процесс 2 получит 2 элемента этого массива и так далее.

Следующие же процессы должны принять это сообщение и для этого смотрят в очередь сообщений, видят это сообщение, собирают информацию в структуру status, после чего получают длину переданного сообщения и создают буфер для его сохранения, после чего просто выводят то, что получили. Для 5 запущенных процессов результат будет вот таким:

```
Process:1 || Count: 1 || Array: 0 
Process:2 || Count: 2 || Array: 0 1 
Process:4 || Count: 4 || Array: 0 1 2 3 
Process:3 || Count: 3 || Array: 0 1 2 
```

Собственно 4 результата потому что нулевой процесс занимается отправкой этих сообщений.
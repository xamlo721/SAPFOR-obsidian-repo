Довольно часто самые сложные алгоритмы требуют огромного количества вычислительных ресурсов в реальных задачах, когда программист пишет код в стандартном его понимании _процедурного_ или _Объектно Ориентированного Программирования(ООП)_, то для особо требовательных алгоритмических задач, которые работают с большим количеством данных и требуют минимизировать время выполнения задачи, необходимо производить оптимизацию.  
  
В основном используют _2 типа_ оптимизации, либо их смесь: _векторизация_ и _распараллеливание_  вычислений. Чем же они отличаются?

Задача оптимизации алгоритма сводится к тому, чтобы правильно выстроить последовательность операций и оптимально разместить данные в Кэше, минимизировав количество возможных пересылок данных из памяти.

Так а чем отличаются векторизация и параллельные вычисления? Векторизация - позволяет выполнять операции над данными целыми векторами. Например для _С++_: если мы используем _AVX_ инструкции, то у нас есть вектора размером 256 бит, куда мы можем поместить float32 элементы. Получится, что мы можем собрать 2 вектора по (256 / 32) = 8 float32 значений. После чего выполнить над ними одну операцию за такт, хотя если бы мы этого не сделали, то вполне возможно, что аналогичные вычисления прошли бы за 8 операций, а то и больше если брать в учет вычисления индексов конкретных элементов. Однако есть одна проблема: компиляторы нынче довольно умны и довольно хорошо справляются с подобной оптимизацией и сами, поэтому большая часть сил уходит на то чтобы правильно организовать данные.

Параллелизация же позволяет пользоваться не только вычислительными возможностями одного процессора, а множеством процессоров, в том числе и в системах с распределенной памятью, и т.п. В подобных системах как правило намного больше вычислительных мощностей, но этим всем нужно уметь управлять и правильно организовывать параллельную работу на конкретных потоках.
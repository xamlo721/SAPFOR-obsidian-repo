## Работа Comm_size, Comm_rank на примере

Более полезным примером такого распараллеливания будет поиск квадратов чисел в заданном диапазоне. Далее идет небольшой пример программы которая это и делает.

```cpp
#include <stdio.h>
#include "mpi.h"

int main(int argc, char **argv) {		
	const int MAX = 20;	
	int rank, size;	
	int n, ibeg, iend;
		
	MPI_Init(&argc, &argv);	
	MPI_Comm_size(MPI_COMM_WORLD, &size);	
	MPI_Comm_rank(MPI_COMM_WORLD, &rank);	
	n = (MAX - 1) / size + 1;	
	ibeg = rank * n + 1;	
	iend = (rank + 1) * n;	
	
	for(int i = ibeg; i <= ((iend > MAX) ? MAX : iend); i++) {		
		printf("Process: %d, %d^2=%d\n", rank, i, i*i);	
	}	
	
	MPI_Finalize();		
	return 0;
}
```

Выход для 5 потоков:

```
Process: 0, 1^2=1
Process: 0, 2^2=4
Process: 0, 3^2=9
Process: 0, 4^2=16
Process: 1, 5^2=25
Process: 1, 6^2=36
Process: 1, 7^2=49
Process: 1, 8^2=64
Process: 2, 9^2=81
Process: 2, 10^2=100
Process: 2, 11^2=121
Process: 2, 12^2=144
Process: 3, 13^2=169
Process: 3, 14^2=196
Process: 3, 15^2=225
Process: 3, 16^2=256
Process: 4, 17^2=289
Process: 4, 18^2=324
Process: 4, 19^2=361
Process: 4, 20^2=400
```

Дабы не вставлять огромные участки с кодом я взял число **MAX=20**. Как видим зная номер процесса на котором исполняется конкретный экземпляр программы уже дает ощутимые возможности, но это далеко не все, ведь сложные задачи далеко не всегда так легко делятся на независимые участки с вычислениями.

Важное замечание, которое вы, возможно, заметите: процессы совсем не обязательно будут выводить в консоль в правильном порядке свои результаты.  [[MPI]]  гарантирует лишь корректность вывода в плане целостности данных, то есть дается гарантия что строка будет выведена целиком, но порядок не гарантируется.

Полагаю, что все кто попробуют запустить такую программу заметят, что выполнение начинается не сразу, а иногда даже из-за этого программа на одном потоке работает горазда быстрее чем параллельная. С виду кажется не совсем логичным, если не знать о том как работает параллельное выполнение, однако на все есть свои веские причины. Когда срабатывает процедура **MPI_Init**, довольно большое количество ресурсов тратится на то чтобы собственно породить эти параллельные потоки и создать среду для их корректного выполнения и именно поэтому маленькие программы и мелкие, краткосрочные вычисления, мало того что не требуют подобной оптимизации, так еще и выполняются медленнее из-за того что время порождения потоков занимает существенную часть из времени всех вычислений, а иногда даже и больше чем сами вычисления. Именно поэтому стоит несколько раз подумать нужно ли распараллеливать данный участок вообще.